using Diligent.Graphics;
using System;
using System.IO;
using System.Numerics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using Vrmac;

namespace RenderSamples
{
	/// <summary>GPU resources we need to render the teapot.</summary>
	class TeapotResources
	{
		IBuffer vsConstants;
		IPipelineState pipelineState;
		IShaderResourceBinding resourceBinding;
		IndexedMesh mesh;

		const string resourcesFolder = "RenderSamples/04-Teapot";

		public TeapotResources( Context context, IRenderDevice device )
		{
			PipelineStateDesc PSODesc = new PipelineStateDesc( false );
			PSODesc.setBufferFormats( context );

			// Primitive topology defines what kind of primitives will be rendered by this pipeline state
			PSODesc.GraphicsPipeline.PrimitiveTopology = PrimitiveTopology.TriangleList;
			// Cull back faces
			PSODesc.GraphicsPipeline.RasterizerDesc.CullMode = CullMode.Back;
			// Enable depth testing
			PSODesc.GraphicsPipeline.DepthStencilDesc.DepthEnable = true;

			iShaderFactory shaderFactory = device.GetShaderFactory();
			// We won't be using the device object after this, `using` is to release the COM interface once finished
			using( iPipelineStateFactory stateFactory = device.CreatePipelineStateFactory() )
			{
				stateFactory.setName( "Teapot PSO" );

				// Compile the two shaders
				ShaderSourceInfo sourceInfo = new ShaderSourceInfo( ShaderType.Vertex, ShaderSourceLanguage.Hlsl );
				sourceInfo.combinedTextureSamplers = true;  // This appears to be the requirement of OpenGL backend.

				// In this tutorial, we will load shaders from resources embedded into this .NET DLL.
				iStorageFolder resources = StorageFolder.embeddedResources( Assembly.GetExecutingAssembly(), resourcesFolder );
				var vs = shaderFactory.compileFromFile( resources, "TeapotVS.hlsl", sourceInfo, "Teapot VS" );
				stateFactory.graphicsVertexShader( vs );

				// Create dynamic uniform buffer that will store our transformation matrix. Dynamic buffers can be frequently updated by the CPU.
				vsConstants = device.CreateDynamicUniformBuffer<VsConstants>( "VS constants CB" );

				// Create a pixel shader
				sourceInfo.shaderType = ShaderType.Pixel;
				var ps = shaderFactory.compileFromFile( resources, "TeapotPS.hlsl", sourceInfo, "Teapot PS" );
				stateFactory.graphicsPixelShader( ps );

				// Define vertex shader input layout

				// Attribute 0 - vertex position
				LayoutElement elt = new LayoutElement( false )
				{
					InputIndex = 0,
					BufferSlot = 0,
					NumComponents = 3,
					ValueType = GpuValueType.Float32,
					IsNormalized = false
				};
				stateFactory.graphicsLayoutElement( elt );

				// Attribute 1 - normals, they are generated by STL loader because we ask for them.
				elt.InputIndex = 1;
				elt.NumComponents = 3;
				stateFactory.graphicsLayoutElement( elt );

				// Define variable type that will be used by default
				PSODesc.ResourceLayout.DefaultVariableType = ShaderResourceVariableType.Static;

				stateFactory.apply( ref PSODesc );
				pipelineState = device.CreatePipelineState( ref PSODesc );
			}

			// Since we did not explicitly specify the type for 'Constants' variable, default
			// type (SHADER_RESOURCE_VARIABLE_TYPE_STATIC) will be used. Static variables never
			// change and are bound directly through the pipeline state object.
			pipelineState.GetStaticVariableByName( ShaderType.Vertex, "Constants" ).Set( vsConstants );

			// Create a shader resource binding object and bind all static resources in it
			resourceBinding = pipelineState.CreateShaderResourceBinding( true );
		}

		public async Task createAsync( IRenderDevice device )
		{
			iStorageFolder resources = StorageFolder.embeddedResources( Assembly.GetExecutingAssembly(), resourcesFolder );
			resources.openRead( "UtahTeapot.stl.gz", out Stream stream );
			float minCos = MathF.Cos( Angle.degrees( 10 ) );
			// float minCos = 1.1f;
			using( stream )
				mesh = await device.loadStlAsync( stream, minCos, "Teapot" );
		}

		public bool haveMesh => null != mesh;
		public BoundingBox meshBoundingBox => mesh.boundingBox.Value;

		/// <summary>This structure must match the layout of "Constants" cbuffer in the vertex shader</summary>
		[StructLayout( LayoutKind.Sequential )]
		struct VsConstants
		{
			Matrix4x4 worldViewProj;
			Matrix4x4 worldView;

			public VsConstants( ref Matrix4x4 wv, ref Matrix4x4 proj )
			{
				Matrix4x4 wvp = wv * proj;
				worldViewProj = wvp.transposed();
				worldView = wv.transposed();
			}
		}

		public void draw( IDeviceContext context, ref Matrix4x4 worldView, ref Matrix4x4 projection )
		{
			var constants = new VsConstants( ref worldView, ref projection );
			context.writeBuffer( vsConstants, ref constants );

			// Set the pipeline state
			context.SetPipelineState( pipelineState );
			// Commit shader resources. RESOURCE_STATE_TRANSITION_MODE_TRANSITION mode makes sure that resources are transitioned to required states.
			context.CommitShaderResources( resourceBinding );

			mesh.draw( context );
		}
	}
}