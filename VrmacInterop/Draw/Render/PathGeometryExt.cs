using Diligent;
using Diligent.Graphics;
using System;
using System.Diagnostics;

namespace Vrmac.Draw
{
	/// <summary>A delegate to consume polylines built by iPathGeometry objects.</summary>
	/// <remarks>Unlike the meshes, you don't actually need them; implemented for lulz, and maybe for debugging.</remarks>
	public delegate void PolylineDelegate( int figureIndex, ReadOnlySpan<Vector2> vertices, bool isFilled, bool isClosed );

	/// <summary>Extension methods for <see cref="iPathGeometry" /> COM interface</summary>
	public static class PathGeometryExt
	{
		/// <summary>Access polylines generated by path geometry.</summary>
		/// <remarks>Despite the name, this method doesn’t download anything.
		/// Instead, it provides a read-only view of the data stored in unmanaged memory, in std::vector&lt;Vector2&gt; C++ containers.</remarks>
		public static void downloadPolylines( this iPolylinePath path, PolylineDelegate poly )
		{
			Span<sPolylineFigure> figures = stackalloc sPolylineFigure[ path.info.figuresCount ];
			path.getFigures( ref figures.GetPinnableReference() );
			int figureIndex = 0;
			foreach( var f in figures )
			{
				if( f.vertexCount > 0 )
				{
					var verts = Unsafe.readSpan<Vector2>( f.firstVertexPointer, f.vertexCount );
					poly( figureIndex, verts, f.isFilled, f.isClosed );
				}
				figureIndex++;
			}
		}

		/// <summary>True if the transformed approximate bounds of the geometry + stroke intersects with a default clipping rectangle [ -1, -1, +1, +1 ]</summary>
		public static bool testApproximateBounds( this iPathGeometry pathGeometry, ref Matrix transform, float strokeWidth = 0 )
		{
			return pathGeometry.ioTestApproximateBounds( ref transform, strokeWidth, IntPtr.Zero );
		}

		/// <summary>True if the transformed approximate bounds of the geometry + stroke intersects with a specified clipping rectangle</summary>
		public static bool testApproximateBounds( this iPathGeometry pathGeometry, ref Matrix transform, ref Rect clipRect, float strokeWidth = 0 )
		{
			unsafe
			{
				fixed ( Rect* pointer = &clipRect )
					return pathGeometry.ioTestApproximateBounds( ref transform, strokeWidth, (IntPtr)pointer );
			}
		}

		/// <summary>Copy vertices out of the mesh</summary>
		public static void copyVertices( this iTriangleMesh mesh, Span<sVertexWithId> span, uint id )
		{
			mesh.copyVertices( ref span.GetPinnableReference(), id );
		}

		/// <summary>Copy opaque triangle indices of the mesh</summary>
		public static void copyOpaqueTriangles( this iTriangleMesh mesh, Span<uint> span, int baseVertex )
		{
			unsafe
			{
				fixed ( uint* pointer = span )
				{
					mesh.copyOpaqueTriangles( (IntPtr)pointer, baseVertex, 4 );
				}
			}
		}
		/// <summary>Copy opaque triangle indices of the mesh, downcasting values to 16-bit integers</summary>
		public static void copyOpaqueTriangles( this iTriangleMesh mesh, Span<ushort> span, int baseVertex )
		{
			unsafe
			{
				fixed ( ushort* pointer = span )
				{
					mesh.copyOpaqueTriangles( (IntPtr)pointer, baseVertex, 2 );
				}
			}
		}

		/// <summary>Copy transparent triangle indices of the mesh</summary>
		public static void copyTransparentTriangles( this iTriangleMesh mesh, Span<uint> span, int baseVertex )
		{
			unsafe
			{
				fixed ( uint* pointer = span )
				{
					mesh.copyTransparentTriangles( (IntPtr)pointer, baseVertex, 4 );
				}
			}
		}

		/// <summary>Copy transparent triangle indices of the mesh, downcasting values to 16-bit integers</summary>
		public static void copyTransparentTriangles( this iTriangleMesh mesh, Span<ushort> span, int baseVertex )
		{
			unsafe
			{
				fixed ( ushort* pointer = span )
				{
					mesh.copyTransparentTriangles( (IntPtr)pointer, baseVertex, 2 );
				}
			}
		}

		/// <summary>Tessellate splines and clip the result to viewport, using default clipping rectangle</summary>
		public static eClipResult buildClippedPolylines( this iPathGeometry path, iPolylinePath poly, Matrix transform, float precision, float strokeWidth = 0 )
		{
			path.buildPolylines( precision, strokeWidth, ref transform, IntPtr.Zero, poly, out var res );
			return res;
		}

		/// <summary>Tessellate splines and clip the result to viewport, using specified clipping rectangle</summary>
		public static eClipResult buildClippedPolylines( this iPathGeometry path, iPolylinePath poly, Rect clipRect, Matrix transform, float precision, float strokeWidth = 0 )
		{
			unsafe
			{
				Rect* clip = &clipRect;
				path.buildPolylines( precision, strokeWidth, ref transform, (IntPtr)clip, poly, out var res );
				return res;
			}
		}

		/// <summary>Clip the polyline to viewport, using default clipping rectangle</summary>
		public static eClipResult clip( this iPolylinePath source, iPolylinePath dest, Matrix transform, float strokeWidth = 0 )
		{
			source.clip( strokeWidth, ref transform, IntPtr.Zero, dest, out var res );
			return res;
		}

		/// <summary>Clip the polyline to viewport, using specified clipping rectangle</summary>
		public static eClipResult clip( this iPolylinePath source, iPolylinePath dest, Rect clipRect, Matrix transform, float strokeWidth = 0 )
		{
			unsafe
			{
				Rect* clip = &clipRect;
				source.clip( strokeWidth, ref transform, (IntPtr)clip, dest, out var res );
				return res;
			}
		}

		/// <summary>Build just the filled mesh</summary>
		public static void createMesh( this iPolylinePath path, iTriangleMesh result, eBuildFilledMesh filledMesh, float pixel )
		{
			Debug.Assert( filledMesh != eBuildFilledMesh.None );
			path.createMesh( result, filledMesh, pixel, IntPtr.Zero );
		}

		/// <summary>Build just the stroked mesh</summary>
		public static void createMesh( this iPolylinePath path, iTriangleMesh result, sStrokeInfo strokeInfo )
		{
			unsafe
			{
				sStrokeInfo* si = &strokeInfo;
				path.createMesh( result, eBuildFilledMesh.None, 0, (IntPtr)si );
			}
		}

		/// <summary>Build both meshes</summary>
		public static void createMesh( this iPolylinePath path, iTriangleMesh result, eBuildFilledMesh filledMesh, float pixel, sStrokeInfo strokeInfo )
		{
			unsafe
			{
				sStrokeInfo* si = &strokeInfo;
				path.createMesh( result, filledMesh, pixel, ( IntPtr)si );
			}
		}
	}
}