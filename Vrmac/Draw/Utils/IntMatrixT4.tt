<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.dll" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>// This file is generated by a T4 template.
namespace Vrmac.Draw
{
	public partial struct IntMatrix
	{
		// Values in all 8 rotation matrices: 1 signed byte / value, 2 * 2 = 4 values / matrix
		static readonly MatrixValues[] allMatrices = new MatrixValues[ 8 ]
		{
			<#= string.Join( ",\n\t\t\t", Matrix.all.Select( Matrix.printNew ) ) #>
		};

		// Index = left hand side matrix, each value contains 3 bits per right hand side matrix
		static readonly uint[] multiplyTable = new uint[ 8 ]
		{
<#
uint[] multiplyTable = new uint[ 8 ];
for( byte i = 0; i < 8; i++ )
{
	Matrix lhs = Matrix.all[ i ];
	var bytes = Enumerable.Range( 0, 8 )
		.Select( j => Matrix.all[ j ] )
		.Select( rhs => lhs * rhs )
		.Select( Matrix.indexOf );
	multiplyTable[ i ] = packBytes( bytes );
}
string multiplyTableString = string.Join( ", ",  multiplyTable.Select( ui => "0x" + ui.ToString( "x" ) ) );

IEnumerable<byte> invertedIndices = Enumerable.Range( 0, 8 )
		.Select( i => Matrix.all[ i ] )
		.Select( m => m.invert() )
		.Select( Matrix.indexOf );

uint invertTable = packBytes( invertedIndices );

string[] names = new string[ 8 ];
names[ 0 ] = "identity";
names[ 4 ] = "flip";
for( int i = 1; i < 4; i++ )
{
	names[ i ] = $"rotate { i * 90 }°";
	names[ i + 4 ] = $"flip + rotate { i * 90 }°";
}

string allNames = string.Join( ", ", names.Select(n => $"\"{n}\"" ) );

#>
			<#= multiplyTableString #>
		};

		// The value contains 3 bits per matrix, 24 bits in total
		const uint invertTable = 0x<#= invertTable.ToString( "x" ) #>;

		// Names of these matrices, useful for debugging
		static readonly string[] matrixNames = new string[ 8 ]
		{
			<#= allNames #>
		};
	}
}<#+

struct Matrix
{
	public readonly sbyte m00, m01, m10, m11;

	public Matrix( int a00, int a01, int a10, int a11 )
	{
		m00 = checked( ( sbyte )a00 );
		m01 = checked( ( sbyte )a01 );
		m10 = checked( ( sbyte )a10 );
		m11 = checked( ( sbyte )a11 );
	}

	public static Matrix operator *( Matrix a, Matrix b )
    {
		// https://www.statology.org/matrix-multiplication-2x2-by-2x2/
		return new Matrix
		(
			a.m00 * b.m00 + a.m01 * b.m10,
			a.m00 * b.m01 + a.m01 * b.m11,
			a.m10 * b.m00 + a.m11 * b.m10,
			a.m10 * b.m01 + a.m11 * b.m11
		);
	}

	public static Matrix fromDegrees( int degrees )
	{
		if( 0 != degrees % 90 )
			throw new ArgumentException();
		int idx = (degrees / 90) & 3;
		// https://en.wikipedia.org/wiki/Rotation_matrix#Common_rotations
		switch( idx )
		{
		case 0:
			return new Matrix( 1, 0, 0, 1 );
		case 1:
			return new Matrix( 0, -1, 1, 0 );
		case 2:
			return new Matrix( -1, 0, 0, -1 );
		case 3:
			return new Matrix( 0, 1, -1, 0 );
		}
		throw new ApplicationException();
	}

	static Matrix horizontalFlip => new Matrix( -1, 0, 0, 1 );

	public static string printNew( Matrix m ) => $"new MatrixValues( { m.m00 }, { m.m01 }, { m.m10 }, { m.m11 } )";

	static IEnumerable<Matrix> allMatrices()
	{
		for( int i = 0; i < 4; i++ )
			yield return fromDegrees( i * 90 );
		for( int i = 0; i < 4; i++ )
			yield return fromDegrees( i * 90 ) * horizontalFlip;
	}

	public static Matrix[] all { get; } = allMatrices().ToArray();

	public static byte indexOf( Matrix m )
	{
		for( byte i = 0; i < 8; i++ )
		{
			// C# implements some default equality for value types. It's slow but this code runs at compile time, performance is irrelevant.
			if( m.Equals( all[ i ] ) )
				return i;
		}
		throw new ApplicationException();
	}

	// It's either -1 or +1 for the 8 matrices we have here
	sbyte determinant()
	{
		return checked( (sbyte)( m00 * m11 - m01 * m10 ) );
	}

	public Matrix invert()
	{
		// https://www.chilimath.com/lessons/advanced-algebra/inverse-of-a-2x2-matrix/
		sbyte det = determinant();
		return new Matrix( m11 / det, -m01 / det, -m10 / det, m00 / det );
	}
}

// Pack 8 bytes, 3 bits / each, into uint
static uint packBytes( IEnumerable<byte> values )
{
	uint result = 0;
	int offset = 0;
	foreach( byte v in values )
	{
		result |= ((uint)v) << offset;
		offset += 3;
	}
	return result;
}
#>